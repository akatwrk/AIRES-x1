#include <Wire.h>
#include "MPU6050.h"
#include <MadgwickAHRS.h>
#include <esp_now.h>
#include <WiFi.h>

// ================= USER CONFIGURATION =================
#define PRINT_SERIAL true 
#define SEND_ESPNOW  true 

// SENSITIVITY
#define BASE_SENSITIVITY 2.5     
#define ARM_SENSITIVITY  1.2     

// FILTERING (NEW! High = Smoother but Slower)
// 0.1 means "Use 10% new data, 90% old data". Great for killing jitter.
float FILTER_STRENGTH = 0.1; 

uint8_t robotMAC[] = {0xC0, 0xCD, 0xD6, 0x85, 0x44, 0xDC};

// ================= HARDWARE =================
MPU6050 imuWrist(0x68);
MPU6050 imuBicep(0x69);
Madgwick filterWrist;
Madgwick filterBicep;

// ================= VARIABLES =================
float off_sh_pitch = 0, off_sh_yaw = 0;
float off_wr_pitch = 0, off_wr_yaw = 0;
float off_elbow_diff = 0; 
float off_wr_roll = 0;

float gW_x, gW_y, gW_z, gB_x, gB_y, gB_z;

// SMOOTHED VALUES (To store history)
float sm_base=90, sm_shoulder=90, sm_elbow=90, sm_wrist=90;

typedef struct struct_message {
  int base;      
  int shoulder;  
  int elbow;     
  int wrist;     
  int gripper;   
} struct_message;

struct_message myData = {90, 90, 90, 90, 90};
esp_now_peer_info_t peerInfo;

void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {}

void setup() {
  Serial.begin(115200);
  Wire.begin(21, 22);
  Wire.setClock(400000); 

  WiFi.mode(WIFI_STA);
  if (esp_now_init() == ESP_OK) {
    esp_now_register_send_cb(OnDataSent);
    memcpy(peerInfo.peer_addr, robotMAC, 6);
    peerInfo.channel = 0;  
    peerInfo.encrypt = false;
    esp_now_add_peer(&peerInfo);
  }

  imuWrist.initialize();
  imuBicep.initialize();
  filterWrist.begin(100); 
  filterBicep.begin(100);

  Serial.println("{\"status\":\"calibrating_gyro\"}");
  long wx=0, wy=0, wz=0, bx=0, by=0, bz=0;
  for (int i=0; i<200; i++) {
    int16_t ax, ay, az, gx, gy, gz;
    imuWrist.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);
    wx+=gx; wy+=gy; wz+=gz;
    imuBicep.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);
    bx+=gx; by+=gy; bz+=gz;
    delay(2);
  }
  gW_x=wx/200.0; gW_y=wy/200.0; gW_z=wz/200.0;
  gB_x=bx/200.0; gB_y=by/200.0; gB_z=bz/200.0;

  Serial.println("{\"status\":\"assume_t_pose\"}");
  delay(2000); 
  
  for(int k=0; k<50; k++) { readSensors(); delay(5); }

  off_sh_yaw   = filterBicep.getYaw();
  off_sh_pitch = filterBicep.getPitch();
  off_wr_pitch = filterWrist.getPitch();
  off_elbow_diff = filterWrist.getYaw() - filterBicep.getYaw();

  Serial.println("{\"status\":\"ready\"}");
}

void readSensors() {
  int16_t ax, ay, az, gx, gy, gz;
  imuWrist.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);
  filterWrist.updateIMU((gx-gW_x)*DEG_TO_RAD, (gy-gW_y)*DEG_TO_RAD, (gz-gW_z)*DEG_TO_RAD, ax, ay, az);
  imuBicep.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);
  filterBicep.updateIMU((gx-gB_x)*DEG_TO_RAD, (gy-gB_y)*DEG_TO_RAD, (gz-gB_z)*DEG_TO_RAD, ax, ay, az);
}

int constrainServo(float val) {
  return constrain((int)val, 0, 180);
}

// LOW PASS FILTER FUNCTION
float smooth(float current, float target) {
  return (current * (1.0 - FILTER_STRENGTH)) + (target * FILTER_STRENGTH);
}

void loop() {
  readSensors();

  float h_sh_yaw   = filterBicep.getYaw();
  float h_sh_pitch = filterBicep.getPitch();
  float h_wr_yaw   = filterWrist.getYaw(); 
  float h_wr_pitch = filterWrist.getPitch();

  // --- CALCULATION ---
  float target_base = 90 + ((h_sh_yaw - off_sh_yaw) * BASE_SENSITIVITY);
  float target_shoulder = 90 + ((h_sh_pitch - off_sh_pitch) * ARM_SENSITIVITY);
  
  float current_elbow_diff = h_wr_yaw - h_sh_yaw;
  float target_elbow = 90 + ((current_elbow_diff - off_elbow_diff) * ARM_SENSITIVITY);
  target_elbow = constrain(target_elbow, 90, 180); 
  
  float target_wrist = 90 + ((h_wr_pitch - off_wr_pitch) * ARM_SENSITIVITY);

  // --- FILTERING (Removes Jitter) ---
  sm_base     = smooth(sm_base, target_base);
  sm_shoulder = smooth(sm_shoulder, target_shoulder);
  sm_elbow    = smooth(sm_elbow, target_elbow); // Especially important for Elbow
  sm_wrist    = smooth(sm_wrist, target_wrist);

  // --- SENDING ---
  myData.base     = constrainServo(sm_base);
  myData.shoulder = constrainServo(sm_shoulder);
  myData.elbow    = constrainServo(sm_elbow);
  myData.wrist    = constrainServo(sm_wrist);
  myData.gripper  = 90; // Fixed

  if (SEND_ESPNOW) {
    esp_now_send(robotMAC, (uint8_t *) &myData, sizeof(myData));
  }

  if (PRINT_SERIAL) {
    Serial.print("{\"b\":"); Serial.print(myData.base);
    Serial.print(",\"s\":"); Serial.print(myData.shoulder);
    Serial.print(",\"e\":"); Serial.print(myData.elbow);
    Serial.print(",\"w\":"); Serial.print(myData.wrist);
    Serial.print(",\"g\":"); Serial.print(myData.gripper);
    Serial.println("}");
  }

  delay(10); 
}
